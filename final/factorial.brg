%{
/* 
 * Instruction selection with postfix.h
 */
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "postfix.h"
#include "y.tab.h"

extern FILE *outfp;
extern int lbl;
extern char *mklbl(int n);
extern char **yynames;

void declaration(NODEPTR_TYPE p, NODEPTR_TYPE p2);
void declType(int type, char *name, NODEPTR_TYPE p);

%}
%include "y.tab.h"
%%
file: 		ROOT(entry_point)
entry_point: 	DECLS(declaration, END)
entry_point: 	DECLS(entry_point, declaration)
declaration: 	DECL(decl_spec, END)			1 { declaration(LEFT_CHILD(p), RIGHT_CHILD(p)); }
declaration: 	DECL(decl_spec, init_decl)		1 { declaration(LEFT_CHILD(p), RIGHT_CHILD(p)); }

decl_spec: 	DECL_SPEC(keywords_spec, decl_spec)
decl_spec: 	DECL_SPEC(type_spec, declarator) 

keywords_spec: 	PUBLIC
keywords_spec: 	PUBLIC_CONST
keywords_spec: 	CONST
keywords_spec: 	END
type_spec: 	VINT					
type_spec: 	VSTR
type_spec: 	VNUMB
type_spec: 	VOID
declarator:	IDENT
declarator:	IDENT_PTR
init_decl: 	INTEGER 				
init_decl: 	STRING
init_decl: 	NUMBER
init_decl: 	IDENT 
init_decl: 	IDENT_PTR
init_decl: 	INIT_DECL(func_param, body) 
func_param: 	END
func_param: 	FUNC_PARAM(param, END)
func_param: 	FUNC_PARAM(param, func_param)
body: 		END
body: 		BODY(params, body)
body: 		BODY(stat, body)
param: 		PARAM(type_spec, declarator)
params: 	PARAM(type_spec, declarator)
params: 	PARAMS(param, params)
stat: 		EXPR(expr)
stat: 		LEFTVALUE(left_val, expr)
expr: 		INTEGER 				1 { fprintf(outfp, pfIMM, p->value.i); }
expr: 		STRING					6 { int i; char *l = mklbl(++lbl);
							char *str = p->value.s;
							fprintf(outfp, pfRODATA pfALIGN pfLABEL, l);
							for (i = 0; str[i] != 0; i++) { fprintf(outfp, pfCHAR, (unsigned char) str[i]); }
							fprintf(outfp, pfTEXT pfADDR, l); }

expr: 		NUMBER					1 { }
expr: 		FUNC_CALL(IDENT, func_invoc_param)	2 { fprintf(outfp, pfCALL pfPUSH, p->SUB(0)->value.s); }
expr: 		ASG(left_val, expr)
expr:		BINOPSUM(expr, expr)			1 { fprintf(outfp, pfADD); }
func_invoc_param: END
func_invoc_param: FUNC_PARAM(expr, END)
func_invoc_param: FUNC_PARAM(expr, func_invoc_param)
left_val: 	IDENT
left_val: 	LEFTVALUE(IDENT, expr)
%%

void function(char *name, int enter, Node *body) {
	int i;
	extern int trace;
	if(trace) printNode(body, stdout, yynames);
	if (body == 0) { fprintf(outfp, pfEXTRN, name); }
	else {
		fprintf(outfp, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, name, pfFUNC, name, enter);
		if (yyselect(body) == 1) { yyerror("No match for syntactic tree."); }
		fprintf(outfp, pfLEAVE pfRET);
		freeNode(body);
	}
}

void program(int enter, Node *body) {
	function("_main", enter, body);
	fprintf(outfp, pfEXTRN pfEXTRN pfEXTRN pfEXTRN, "prints", "printi", "println", "readi");
}

void declaration(NODEPTR_TYPE p, NODEPTR_TYPE p2) {
	char *name = RIGHT_CHILD(RIGHT_CHILD(p))->value.s;
	int keySpec = OP_LABEL(LEFT_CHILD(p)),
	    typSpec = OP_LABEL(LEFT_CHILD(RIGHT_CHILD(p)));
	if (OP_LABEL(p2) == END) { /* declaration without init */
		switch (keySpec) {
			case PUBLIC: 
				fprintf(outfp, pfEXTRN, name);
				break;
			default:
				declType(typSpec, name, p2);
				break;
		}
	} else {
		switch (keySpec) {
			case PUBLIC:
				//fprintf(outfp, pfEXTRN, name);
				break;
			case CONST:
				fprintf(outfp, pfRODATA);
				break;
			case PUBLIC_CONST:
				fprintf(outfp, pfRODATA, name);
		}
		declType(typSpec, name, p2);
	}
}

void declType(int type, char *name, NODEPTR_TYPE p) {
	switch(type) {
		case VINT: 
			if (OP_LABEL(p) == END) {
				fprintf(outfp, pfBSS pfALIGN pfLABEL pfBYTE pfTEXT, name, 4);
			} else {
				fprintf(outfp, pfBSS pfALIGN pfLABEL pfINTEGER pfTEXT, name, p->value.i);
			}
		break;
	}
}
